<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Knapsack Visualization</title>
<style>
  body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background-color: #f4f4f4;
}

h1, h2 {
  color: #2c3e50;
}

/* Form styles */
#knapsack-form {
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 20px;
}

label {
  display: inline-block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="number"] {
  width: 100px;
  padding: 8px;
  margin-bottom: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:hover {
  background-color: #2980b9;
}

#pause-btn {
  background-color: #e74c3c;
  margin-bottom: 20px;
}

#pause-btn:hover {
  background-color: #c0392b;
}

#innerCell {
  width: 80px !important;
  height: auto;
}

/* Table styles */
table {
  border-collapse: collapse;
  width: 100%;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

td, th {
  border: 1px solid #ddd;
  padding: 12px;
  text-align: center;
}

th {
  background-color: #3498db;
  color: white;
  font-weight: bold;
}

/* Highlight styles */
.highlight {
  background-color: #ffeaa7;
  transition: background-color 0.3s;
}

.item-highlight {
  background-color: #55efc4;
  transition: background-color 0.3s;
}

.no-take {
  background-color: #fab1a0;
  color: #d63031;
  text-align: center;
  padding: 20px;
  border-radius: 8px;
  margin-top: 20px;
  font-weight: bold;
}


</style>
</head>
<body>

  <div class="container">
    <header>
        <h1>Knapsack Problem Visualization</h1>
    </header>

    <main>
        <section id="input-section">
            <form id="knapsack-form">
                <div class="form-group">
                    <label for="capacity">Knapsack Capacity:</label>
                    <input type="number" id="capacity" name="capacity" required>
                </div>

                <div id="items-input">
                    <h3>Items</h3>
                    <div class="item-row">
                        <span class="form-group">
                            <label for="weight-1">Weight:</label>
                            <input type="number" name="weight" class="item-weight" required>
                        </span>
                        <span class="form-group">
                            <label for="value-1">Value:</label>
                            <input type="number" name="value" class="item-value" required>
                        </span>
                    </div>
                </div>

                <div class="button-group">
                    <button type="button" id="add-item-btn">Add Item</button>
                    <button type="submit">Start Visualization</button>
                </div>
            </form>
        </section>

        <section id="visualization-section">
            <div class="control-panel">
                <button id="pause-btn">Pause</button>
            </div>


            <div id="table-container">
                <h2>Knapsack Table</h2>
                <div class="table-wrapper">
                    <table id="knapsack-table"></table>
                </div>
            </div>

            <div id="no-take-cell" class="no-take" style="display:none;">
                No Take :(
            </div>
        </section>
    </main>
</div>

<script>

const addItemRow = () => {
  const itemsInputDiv = document.getElementById('items-input');
  const newItemRow = document.createElement('div');
  newItemRow.classList.add('item-row');
  newItemRow.innerHTML = `
    <label for="weight">Weight:</label>
    <input type="number" name="weight" class="item-weight" required>
    <label for="value">Value:</label>
    <input type="number" name="value" class="item-value" required>
  `;
  itemsInputDiv.appendChild(newItemRow);
}
let paused = false;
document.getElementById('add-item-btn').addEventListener('click', addItemRow);
const clearKnapsackTable = () => {
  const tableElement = document.getElementById('knapsack-table');
  // Remove all rows except the header row
  tableElement.innerHTML = ''; 
}

const handlePauseSubmit = (event) => {
    event.preventDefault();
    paused = !paused;
    console.log('p/up')
    console.log(paused)
}
document.getElementById('pause-btn').addEventListener('click', handlePauseSubmit);
const handleFormSubmit = (event) => {
  event.preventDefault();
  
  clearKnapsackTable();
  const capacity = parseInt(document.getElementById('capacity').value);
  const itemRows = document.querySelectorAll('.item-row');
  let items = [];

  itemRows.forEach((itemRow, index) => {
    const weight = parseInt(itemRow.querySelector('.item-weight').value);
    const value = parseInt(itemRow.querySelector('.item-value').value);
    items.push({ weight, value });
  });


  const result = knapsackSolver(items, capacity);
  itemRows.innerHTML = ''
  items = []

}
document.getElementById('knapsack-form').addEventListener('submit', handleFormSubmit);
function knapsackSolver (items, capacity) {
    // okay so this is INCREDIBLY cursed but bear with me - I kept running into these weird off-by-one errors that have to do with the very weird way this approach uses tables/
    // this was the easiest way to fix this - we add an extra item and just don't make a row with it xd
  items.push({weight: 1000, value: 0})
  const weightAvailable = capacity;
  const delayTime = 1000; 




  const table = [];
  const tableElement = document.getElementById('knapsack-table');
  
  // header row
  const headerRow = document.createElement('tr');
  const eligibleItemHeader = document.createElement('th');
  eligibleItemHeader.textContent = 'Eligible Item';
  headerRow.appendChild(eligibleItemHeader);
  console.log(items)
  for (let ccapacity = 0; ccapacity <= weightAvailable; ccapacity += 1) {
    const th = document.createElement('th');
    th.textContent = `Capacity ${ccapacity}`;
    headerRow.appendChild(th);
  }
  tableElement.appendChild(headerRow);


  //item column
  for (let itemIndex = 0; itemIndex <= items.length; itemIndex += 1) {
    const row = [];
    const tr = document.createElement('tr');
    table.push(row);

    const eligibleItemTd = document.createElement('td');
    if (itemIndex > 0) {
      eligibleItemTd.textContent = `Item ${itemIndex} (Weight: ${items[itemIndex - 1].weight}, Value: ${items[itemIndex - 1].value})`;
      eligibleItemTd.setAttribute('id', `eligible-item-${itemIndex - 1}`);
    }

    //we exclude the last fake item because I didn't want to fix the off-by-one error
    if (itemIndex != items.length) {
        tr.appendChild(eligibleItemTd);

    for (let capacity = 0; capacity <= weightAvailable; capacity += 1) {
      const td = document.createElement('td');
      td.classList.add('innerCell')
      if (itemIndex === 0) {
        row.push({ value: 0, items: [], weight: 0, remainingCapacity: capacity });
        td.innerHTML = `Value: 0<br>Weight: 0<br>Items: <br>Rem. Cap.: ${capacity}`;
      } else {
        row.push({ value: null, items: [], weight: null, remainingCapacity: null });
      }
      tr.appendChild(td);
    }
    tableElement.appendChild(tr);
}
  }

  const delay = ms => new Promise(res => setTimeout(res, ms));

  const decideToTakeOrNot = (decisionsSoFar, item, capacity) => {
    let takeValue = 0;
    let notTakeValue = decisionsSoFar[capacity].value || 0;
    let takeItems = [];
    let takeWeight = 0;
    let remainingCapacity = capacity;
    let newRemainingCapacity;
    if (item.weight <= capacity) {
      //minus the weight of all other items in that square, UGH
      newRemainingCapacity = capacity - item.weight;
      takeValue = item.value + decisionsSoFar[newRemainingCapacity].value;
      takeItems = [...decisionsSoFar[newRemainingCapacity].items, item];
      takeWeight = item.weight + decisionsSoFar[newRemainingCapacity].weight;
    }
    if (takeValue > notTakeValue) {
        //console.log('taken!')
      return { value: takeValue, items: takeItems, weight: takeWeight, remainingCapacity: capacity-takeWeight};
      
    } else {
       // console.log('not taken!')
      return { value: notTakeValue, items: decisionsSoFar[capacity].items, weight: decisionsSoFar[capacity].weight || 0, remainingCapacity: decisionsSoFar[capacity].remainingCapacity || 0};
      
    }
  }
  const updateTable = async () => {
    // so we start at index 2 because there's the header and then first row, which are always static and we don't mess with them
  for (let itemIndex = 2; itemIndex < items.length+1; itemIndex += 1) { 
    for (let capacity = 0; capacity <= weightAvailable; capacity += 1) {
      // 
      const currentItem = items[itemIndex - 2]; 
      const td = tableElement.rows[itemIndex].cells[capacity + 1]; // because the leftmost column is the items
      const itemElement = document.getElementById(`eligible-item-${itemIndex - 2}`); //because the item elemenents ARE correctly indexed
      const noTakeCell = document.getElementById('no-take-cell');

      // highlights for visual clarity
      td.classList.add('highlight');
      itemElement.classList.add('item-highlight');
      while (paused) {
        await delay(2000)
      }
      //highlight no take cell
      const notTakeRowIndex = itemIndex - 1; //header
      const notTakeTd = tableElement.rows[notTakeRowIndex].cells[capacity + 1]; //item column
      notTakeTd.classList.add('highlight');
      await delay(delayTime);

     //highlight the take cell if it exists
      if (currentItem.weight <= capacity) {
        const remainingCapacity = capacity - currentItem.weight;
        const takeRowIndex = itemIndex - 1;
        const takeColumnIndex = remainingCapacity + 1; // item column
        if (takeColumnIndex >= 1 && takeRowIndex >= 0) {
          const takeTd = tableElement.rows[takeRowIndex].cells[takeColumnIndex];
          takeTd.classList.add('highlight');
          await delay(delayTime);
          takeTd.classList.remove('highlight');
        }
      } else {
        noTakeCell.style.display = 'block';
        await delay(delayTime);
        noTakeCell.style.display = 'none';
      }
      while (paused) {
        await delay(2000)
      }
      const newValue = decideToTakeOrNot(table[itemIndex - 1], currentItem, capacity);
      console.log(itemIndex + " itemIndex " + capacity + " is capacity")
      table[itemIndex][capacity] = newValue;
      while(paused) {
        await delay(2000)
      } 
      // update current~
      td.innerHTML = `Value: ${newValue.value}<br>Weight: ${newValue.weight}<br>Items: ${newValue.items.map((item, index) => `${items.indexOf(item) + 1}`).join(', ')}<br>Rem. Cap.: ${newValue.remainingCapacity}`;

      td.classList.remove('highlight');
      itemElement.classList.remove('item-highlight');
      notTakeTd.classList.remove('highlight');
      while(paused) {
        await delay(2000)
      }
      await delay(delayTime);
    }
    
  }

}
updateTable()
}



</script>

</body>
</html>
